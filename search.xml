<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring Boot 自动装配的原理]]></title>
    <url>%2F2017%2F06%2F21%2FSpring_Boot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[在Spring Boot的启动过程中，我们只要通过配置 @SpringBootApplication 就能让Spring Boot程序跑起来，这究竟有什么神奇的？ 先来看看 @SpringBootApplication 注解有什么奇妙之处： @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) }) public @interface SpringBootApplication { .... } 在上面的代码中 有一段 @EnableAutoConfiguration, 就是这个注解起了非常奇妙的作用，在往下跟 看看 @EnableAutoConfiguration 注解，看到其内部还有一个 @Import(EnableAutoConfigurationImportSelector.class) ，打开这个类 @Override public String[] selectImports(AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return NO_IMPORTS; } try { AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader .loadMetadata(this.beanClassLoader); AnnotationAttributes attributes = getAttributes(annotationMetadata); List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); configurations = removeDuplicates(configurations); configurations = sort(configurations, autoConfigurationMetadata); Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = filter(configurations, autoConfigurationMetadata); fireAutoConfigurationImportEvents(configurations, exclusions); return configurations.toArray(new String[configurations.size()]); } catch (IOException ex) { throw new IllegalStateException(ex); } } 找到 getCandidateConfigurations(annotationMetadata, attributes) 这个方法，从字面意思上可以看出是获取候选的配置类，这个函数最终的作用是加载 spring.factories 中前缀为的 org.springframework.boot.autoconfigure.EnableAutoConfiguration类到内存中，详细的配置清单 org.springframework.boot.autoconfigure.EnableAutoConfiguration=\ org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\ org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\ org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\ org.springframework.boot.autoconfigure.MessageSourceAutoConfiguration,\ org.springframework.boot.autoconfigure.PropertyPlaceholderAutoConfiguration,\ org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\ org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\ org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\ org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\ org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\ org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\ org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\ org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\ org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\ org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\ org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\ org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\ org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\ org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\ org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\ org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\ org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\ org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\ org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\ org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\ org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\ org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\ org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\ org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\ org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\ org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\ org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\ org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\ org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\ org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\ org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\ org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\ org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\ org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\ org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\ org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\ org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\ org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\ org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\ org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\ org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\ org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\ org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\ org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\ org.springframework.boot.autoconfigure.jms.hornetq.HornetQAutoConfiguration,\ org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\ org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\ org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\ org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\ org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\ org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\ org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\ org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\ org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\ org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\ org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\ org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\ org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\ org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\ org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\ org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\ org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\ org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\ org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\ org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\ org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\ org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\ org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\ org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\ org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\ org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\ org.springframework.boot.autoconfigure.velocity.VelocityAutoConfiguration,\ org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\ org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\ org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\ org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\ org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\ org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\ org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\ org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\ org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\ org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\ org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\ org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\ org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\ org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\ org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration 那么我们自定义的配置类在什么时候被加载的？ 在Spring Boot 程序启动的时候，默认会扫描Application类所在包及其子包， 我们自定义的Configuration一般会在子包中被实现，所以当Spring 启动的时候会把其扫入到容器中进行管理。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mybatis中的插件使用]]></title>
    <url>%2F2017%2F04%2F21%2Fmybatis%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在使用Mybatis作为日常的ORM框架时12121，会经常碰到一些定制化的需求，比如在检索数据时加上一些 userContext 的credential，以限定检索的范围，又或者在插入数据时，需要加上审计相关的信息，这个时候Mybatis强大的插件机制就派上用场了，Mybatis-pagehelper中就使用了这样的插件机制来做分页. 比如有这样一个需求，当更新一条记录时，记录下谁更新的，更新时间，属于那个租户下的，我们可以认为这就是个拦截器，针对创建时间，创建用户，以下就是这个小例子： mybatis-config.xml 1234567&lt;configuration&gt; .... &lt;plugins&gt; &lt;plugin interceptor=&quot;com.test.mybatis.TimestampInterceptor&quot;/&gt; &lt;/plugins&gt; &lt;/configuration&gt; TimestampInterceptor.java 在这里主要是实现#intercept方法和#plugin方法，前面的方式主要用来处理核心拦截业务处理， plugin用来把这个拦截器加入到 Mybatis的整个拦截器链，这样拦截器才会起作用，否则不处在Mybatis的拦截器链中，是不能发挥拦截器的作用的 12345678910111213141516171819202122232425262728293031323334353637383940@Intercepts(&#123; @Signature(type = Executor.class, method = "update", args = &#123; MappedStatement.class, Object.class &#125;)&#125;)public class TimestampInterceptor implements Interceptor &#123; /** the main entry of interceptor */ @Override public Object intercept()&#123; //do what you need do in this interceptor here Object parameterObj = invocation.getArgs()[1]; SqlCommandType type = ((MappedStatement) invocation.getArgs()[0]).getSqlCommandType(); if (parameterObj instanceof BaseEntity) &#123; populateDate(parameterObj, type); &#125; &#125; private void populateData(Object param, SqlCommandType commandType) &#123; if (!(obj instanceof BaseEntity)) &#123; return; &#125; BaseEntity entity = (BaseEntity) obj; RequestInfo context = RequestContext.get(); UUID userId = context == null ? null : context.getUserContext().getUserId().asUUID(); UUID tenantId = context == null ? null : context.getCompanyId().asUUID(); switch (commandType) &#123; case INSERT: entity.setCreatedBy(userId); entity.setCreatedTime(Instant.now()); break; case UPDATE: entity.setUpdatedBy(userId); entity.setUpdatedTime(Instant.now()); break; &#125; &#125; @Override public Object plugin(Object target) &#123; return Plugin.wrap(target, this); &#125;&#125; BaseEntity.java 12345678public class BaseEntity&#123; private UUID createdBy; private UUID updatedBy; private Instant createdTime; private Instant updatedTime; private UUID tenantId; //ignore other fields&#125; AuctionRecord.java 123public class AuctionRecord extends BaseEntity &#123; //other fields in this entity&#125; 使用过程还是很简单的，如下面的例子： AuctionRecordDAOImpl.java 12345678public AuctionRecordDAOImpl implements AuctionRecordDAO &#123; //ignore other methods @Autowired private AuctionRecordMapper auctionRecordMapper; void create(AuctionRecord record) &#123; auctionRecordMapper.insert(record); &#125;&#125; 当插入一条AuctionRecord的时候就会触发 TimestampInterceptor 这个拦截器，并且执行拦截器中的#intercept方法，在上面的例子中实现的功能是插入时间，创建人等信息. 至于Mybatis的拦截器具体是怎么实现的，下面会有分享.]]></content>
  </entry>
</search>
