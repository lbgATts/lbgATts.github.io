<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Zookeeper 实现的分布式锁]]></title>
    <url>%2F2018%2F01%2F21%2FZookeeper%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%2F</url>
    <content type="text"><![CDATA[我们知道Zookeeper是分布式领域一个非常重要的框架，大多用在做注册中心，也可以用来做负载均衡，当然也可以用来做分布式锁，本文尝试用Zookeeper来实现一个原型版本的分布式锁： 分布式锁的实现原理也很简单：在Zookeeper中，如果一个线程能够先创建一个临时节点(这个节点必须是实现约定好的)，那么其他的服务如果还走Zookeeper的话，它也会尝试去创建这样一个节点，但是在Zookeeper里，树形结构里是不允许相同节点存在的，在节点上不行，在节点的节点也不行，其实这是个递归概念啦，所以利用这个特定可以达到互斥访问的一个特点，当获得锁的线程执行完了业务逻辑，它就把这个节点删除，其他的线程再次争抢谁先创建这个节点，谁就获得这个分布式锁 引入这两个最重要的依赖12345678910111213&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.3&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt; Lock.java1234public interface Lock &#123; void getLock(); void unlock();&#125; ZookeeperAbstractLock.java12345678910111213141516171819public abstract class ZookeeperAbstractLock implements Lock &#123; public void getLock() &#123; if (tryLock()) &#123; System.out.println(&quot;获取了锁，可以开始业务逻辑&quot;); return; &#125; else &#123; //等待完成之后重新获取锁 waitLock(); getLock(); &#125; &#125; protected abstract boolean tryLock(); //添加监听器必须在这里添加，在外面的话，在第一次connection后会断掉，后面就不会自动添加了 protected abstract void waitLock();&#125; ZookeeperDistributeLock.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class ZookeeperDistributeLock extends ZookeeperAbstractLock &#123; private static final String ZK_CONN_STR = &quot;127.0.0.1:2181&quot;; private ZkClient client = new ZkClient(ZK_CONN_STR); private CountDownLatch downLatch = null; private static final String PATH = &quot;/lock&quot;; protected void waitLock() &#123; IZkDataListener dataListener = new IZkDataListener() &#123; public void handleDataChange(String s, Object o) throws Exception &#123; System.out.println(&quot;节点变动事件被调用&quot;); &#125; public void handleDataDeleted(String s) throws Exception &#123; System.out.println(&quot;节点删除事件被调用&quot;); downLatch.countDown(); &#125; &#125;; client.subscribeDataChanges(PATH, dataListener); try &#123; if (client.exists(PATH)) &#123; //添加节点监听事件 downLatch = new CountDownLatch(1); downLatch.await(); //等其他线程执行完 countDown() &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; client.unsubscribeDataChanges(PATH, dataListener); &#125; protected boolean tryLock() &#123; //尝试获得锁，应该只是去尝试创建节点，如果失败就说明锁被占用 try &#123; client.create(PATH, null, CreateMode.EPHEMERAL); return true; &#125; catch(Exception e) &#123; return false; &#125; &#125; public void unlock() &#123; //因为是临时节点，在一个线程获得锁 然后执行unLock的时候，关闭连接 创建的临时节点会被删除，会触发上面的监听 client.close(); &#125;&#125; 在来一个简单的测试类： 123456789101112131415161718public class Test implements Runnable &#123; private static int count = 0; private ZookeeperDistributeLock lock = new ZookeeperDistributeLock(); public void run() &#123; lock.getLock(); System.out.println(++count); lock.unlock(); &#125; public static void main(String[] args) &#123; for (int i=0;i&lt;10;i++) &#123; new Thread(new Test()).start(); &#125; &#125;&#125; 输出是正常的有序，就不赘述了]]></content>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 自动装配的原理]]></title>
    <url>%2F2017%2F06%2F21%2FSpring_Boot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[在Spring Boot的启动过程中，我们只要通过配置 @SpringBootApplication 就能让Spring Boot程序跑起来，这究竟有什么神奇的？ 先来看看 @SpringBootApplication 注解有什么奇妙之处： @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) }) public @interface SpringBootApplication { .... } 在上面的代码中 有一段 @EnableAutoConfiguration, 就是这个注解起了非常奇妙的作用，在往下跟 看看 @EnableAutoConfiguration 注解，看到其内部还有一个 @Import(EnableAutoConfigurationImportSelector.class) ，打开这个类 @Override public String[] selectImports(AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return NO_IMPORTS; } try { AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader .loadMetadata(this.beanClassLoader); AnnotationAttributes attributes = getAttributes(annotationMetadata); List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); configurations = removeDuplicates(configurations); configurations = sort(configurations, autoConfigurationMetadata); Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = filter(configurations, autoConfigurationMetadata); fireAutoConfigurationImportEvents(configurations, exclusions); return configurations.toArray(new String[configurations.size()]); } catch (IOException ex) { throw new IllegalStateException(ex); } } 找到 getCandidateConfigurations(annotationMetadata, attributes) 这个方法，从字面意思上可以看出是获取候选的配置类，这个函数最终的作用是加载 spring.factories 中前缀为的 org.springframework.boot.autoconfigure.EnableAutoConfiguration类到内存中，详细的配置清单 org.springframework.boot.autoconfigure.EnableAutoConfiguration=\ org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\ org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\ org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\ org.springframework.boot.autoconfigure.MessageSourceAutoConfiguration,\ org.springframework.boot.autoconfigure.PropertyPlaceholderAutoConfiguration,\ org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\ org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\ org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\ org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\ org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\ org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\ org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\ org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\ org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\ org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\ org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\ org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\ org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\ org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\ org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\ org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\ org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\ org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\ org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\ org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\ org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\ org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\ org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\ org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\ org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\ org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\ org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\ org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\ org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\ org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\ org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\ org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\ org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\ org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\ org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\ org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\ org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\ org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\ org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\ org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\ org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\ org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\ org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\ org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\ org.springframework.boot.autoconfigure.jms.hornetq.HornetQAutoConfiguration,\ org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\ org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\ org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\ org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\ org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\ org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\ org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\ org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\ org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\ org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\ org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\ org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\ org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\ org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\ org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\ org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\ org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\ org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\ org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\ org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\ org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\ org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\ org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\ org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\ org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\ org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\ org.springframework.boot.autoconfigure.velocity.VelocityAutoConfiguration,\ org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\ org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\ org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\ org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\ org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\ org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\ org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\ org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\ org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\ org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\ org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\ org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\ org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\ org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\ org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration 那么我们自定义的配置类在什么时候被加载的？ 在Spring Boot 程序启动的时候，默认会扫描Application类所在包及其子包， 我们自定义的Configuration一般会在子包中被实现，所以当Spring 启动的时候会把其扫入到容器中进行管理。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mybatis中的插件使用]]></title>
    <url>%2F2017%2F04%2F21%2Fmybatis%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在使用Mybatis作为日常的ORM框架时，会经常碰到一些定制化的需求，比如在检索数据时加上一些 userContext 的credential，以限定检索的范围，又或者在插入数据时，需要加上审计相关的信息，这个时候Mybatis强大的插件机制就派上用场了，Mybatis-pagehelper中就使用了这样的插件机制来做分页. 比如有这样一个需求，当更新一条记录时，记录下谁更新的，更新时间，属于那个租户下的，我们可以认为这就是个拦截器，针对创建时间，创建用户，以下就是这个小例子： mybatis-config.xml 1234567&lt;configuration&gt; .... &lt;plugins&gt; &lt;plugin interceptor=&quot;com.test.mybatis.TimestampInterceptor&quot;/&gt; &lt;/plugins&gt; &lt;/configuration&gt; TimestampInterceptor.java 在这里主要是实现#intercept方法和#plugin方法，前面的方式主要用来处理核心拦截业务处理， plugin用来把这个拦截器加入到 Mybatis的整个拦截器链，这样拦截器才会起作用，否则不处在Mybatis的拦截器链中，是不能发挥拦截器的作用的 12345678910111213141516171819202122232425262728293031323334353637383940@Intercepts(&#123; @Signature(type = Executor.class, method = "update", args = &#123; MappedStatement.class, Object.class &#125;)&#125;)public class TimestampInterceptor implements Interceptor &#123; /** the main entry of interceptor */ @Override public Object intercept()&#123; //do what you need do in this interceptor here Object parameterObj = invocation.getArgs()[1]; SqlCommandType type = ((MappedStatement) invocation.getArgs()[0]).getSqlCommandType(); if (parameterObj instanceof BaseEntity) &#123; populateDate(parameterObj, type); &#125; &#125; private void populateData(Object param, SqlCommandType commandType) &#123; if (!(obj instanceof BaseEntity)) &#123; return; &#125; BaseEntity entity = (BaseEntity) obj; RequestInfo context = RequestContext.get(); UUID userId = context == null ? null : context.getUserContext().getUserId().asUUID(); UUID tenantId = context == null ? null : context.getCompanyId().asUUID(); switch (commandType) &#123; case INSERT: entity.setCreatedBy(userId); entity.setCreatedTime(Instant.now()); break; case UPDATE: entity.setUpdatedBy(userId); entity.setUpdatedTime(Instant.now()); break; &#125; &#125; @Override public Object plugin(Object target) &#123; return Plugin.wrap(target, this); &#125;&#125; BaseEntity.java 12345678public class BaseEntity&#123; private UUID createdBy; private UUID updatedBy; private Instant createdTime; private Instant updatedTime; private UUID tenantId; //ignore other fields&#125; AuctionRecord.java 123public class AuctionRecord extends BaseEntity &#123; //other fields in this entity&#125; 使用过程还是很简单的，如下面的例子： AuctionRecordDAOImpl.java 12345678public AuctionRecordDAOImpl implements AuctionRecordDAO &#123; //ignore other methods @Autowired private AuctionRecordMapper auctionRecordMapper; void create(AuctionRecord record) &#123; auctionRecordMapper.insert(record); &#125;&#125; 当插入一条AuctionRecord的时候就会触发 TimestampInterceptor 这个拦截器，并且执行拦截器中的#intercept方法，在上面的例子中实现的功能是插入时间，创建人等信息. 至于Mybatis的拦截器具体是怎么实现的，下面会有分享.]]></content>
  </entry>
</search>
